import {
  TextEditor,
  EditorState,
  EditorView,
  Caret
} from './src/index.js';

new TextEditor({
  view: new EditorView({
    style: {
      fontSize: 15,
      lineHeight: 1.25,
      editorPadding: 0,
      font: 'Monospace',
      editorBackgroundColor: '#fff',
      textColor: '#000',
      caretColor: '#000',
      caretWidth: 2,
    }
  }),
  state: new EditorState({
    caret: new Caret(),
    lines: [
      "/** Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum. **/",
      "",
      "import { Component } from 'preact'",
      "import { isKeyHotkey } from 'is-hotkey'",
      "import classes from './style.scss'",
      "",
      "import { Tooltip } from '@/components/Tooltip'",
      "import { getStateIndices } from './utils/get-state-indices'",
      "import { applyUpdates } from './utils/apply-updates'",
      "import { removeEmptyText, simplifyDocument } from './utils/simplify'",
      "import { getTextIndexInLine, getTextInDocument } from './utils/query-state'",
      "import { applyBlockOperation } from './applyBlockOperation'",
      "import { TextEditor } from './TextEditor'",
      "import {",
      "  TRANSFER_TYPES,",
      "  setEventTransfer,",
      "  getEventTransfer",
      "} from './utils/handle-paste'",
      "import {",
      "  getLastItemOfArray,",
      "  setLastItemOfArray,",
      "  removeItemFromArray,",
      "  setItem",
      "} from '@/helpers/immutable'",
      "",
      "const isRedoHotkey = isKeyHotkey('mod+y')",
      "const isUndoHotkey = isKeyHotkey('mod+z')",
      "const isBackspaceHotkey = isKeyHotkey('backspace')",
      "",
      "function getSelectedFragment (document, caretPosition, dontSimplify) {",
      "  if (caretPosition.start === caretPosition.end) {",
      "    const indices = getStateIndices(document, caretPosition.start)",
      "",
      "    return {",
      "      lines: [",
      "        {",
      "          content: [",
      "            {",
      "              text: '',",
      "              attributes:",
      "                document.lines[indices.lineIndex].content[indices.contentIndex]",
      "                  .attributes",
      "            }",
      "          ],",
      "          attributes: document.lines[indices.lineIndex].attributes",
      "        }",
      "      ]",
      "    }",
      "  }",
      "",
      "  const selectedFragment = applyUpdates(document, [",
      "    {",
      "      type: 'deleteAmount',",
      "      amount: caretPosition.start",
      "    },",
      "    {",
      "      type: 'retainAmount',",
      "      amount: caretPosition.end - caretPosition.start",
      "    },",
      "    {",
      "      type: 'deleteAmount',",
      "      amount: getTextInDocument(document).length - caretPosition.end",
      "    }",
      "  ])",
      "",
      "  if (dontSimplify) {",
      "    return selectedFragment",
      "  }",
      "",
      "  const simplifiedFragment = setItem(",
      "    selectedFragment,",
      "    'lines',",
      "    selectedFragment.lines",
      "      .map(removeEmptyText)",
      "      .filter(line => line.content.length)",
      "  )",
      "",
      "  return simplifiedFragment.lines.length === 0",
      "    ? selectedFragment",
      "    : simplifiedFragment",
      "}",
      "",
      "function getInlineAttributesAtPosition (document, position) {",
      "  return getSelectedFragment(document, { start: position, end: position })",
      "    .lines[0].content[0].attributes",
      "}",
      "",
      "export class RichEditorBase extends Component {",
      "  constructor (props) {",
      "    super(props)",
      "",
      "    this.state = {",
      "      revisions: [",
      "        { document: props.document, caretPosition: this.caretPosition }",
      "      ],",
      "      revisionIndex: 0,",
      "      caretPosition: { start: 0, end: 0 },",
      "      selectedAttributes: null,",
      "      focused: false",
      "    }",
      "  }",
      "",
      "  get caretPosition () {",
      "    return this.state.caretPosition",
      "  }",
      "",
      "  componentDidUpdate (prevProps, prevState) {",
      "    if (",
      "      this.getDocument(prevState) !== this.getDocument() &&",
      "      this.props.onDocumentChange",
      "    ) {",
      "      this.props.onDocumentChange(document)",
      "    }",
      "  }",
      "",
      "  undo () {",
      "    this.setState(state => {",
      "      const newRevisionIndex = Math.max(state.revisionIndex - 1, 0)",
      "",
      "      return {",
      "        caretPosition: state.revisions[newRevisionIndex].caretPosition,",
      "        revisionIndex: newRevisionIndex",
      "      }",
      "    })",
      "  }",
      "",
      "  redo () {",
      "    this.setState(state => {",
      "      const newRevisionIndex = Math.min(",
      "        state.revisionIndex + 1,",
      "        state.revisions.length - 1",
      "      )",
      "",
      "      return {",
      "        caretPosition: state.revisions[newRevisionIndex].caretPosition,",
      "        revisionIndex: newRevisionIndex",
      "      }",
      "    })",
      "  }",
      "",
      "  pushState ({",
      "    document,",
      "    oldCaretPosition = this.caretPosition,",
      "    newCaretPosition = this.caretPosition",
      "  }) {",
      "    this.setState(state => {",
      "      const revisions = state.revisions.slice(0, state.revisionIndex + 1)",
      "",
      "      return {",
      "        revisions: [",
      "          ...setLastItemOfArray(revisions, {",
      "            ...getLastItemOfArray(revisions),",
      "            caretPosition: oldCaretPosition",
      "          }),",
      "          { document, caretPosition: newCaretPosition }",
      "        ],",
      "        revisionIndex: state.revisionIndex + 1,",
      "        caretPosition: newCaretPosition",
      "      }",
      "    })",
      "  }",
      "",
      "  onKeyDown = e => {",
      "    if (isRedoHotkey(e.originalEvent)) {",
      "      this.redo()",
      "      e.preventDefault()",
      "    }",
      "",
      "    if (isUndoHotkey(e.originalEvent)) {",
      "      this.undo()",
      "      e.preventDefault()",
      "    }",
      "",
      "    if (",
      "      this.props.getLineAttributesAfterRemovingLine &&",
      "      this.caretPosition.start === this.caretPosition.end &&",
      "      isBackspaceHotkey(e.originalEvent)",
      "    ) {",
      "      const { lineIndex, contentIndex, stringIndex } = getStateIndices(",
      "        this.getDocument(),",
      "        this.caretPosition.start",
      "      )",
      "",
      "      if (contentIndex === 0 && stringIndex === 0) {",
      "        const document = this.getDocument()",
      "        const newAttributes = this.props.getLineAttributesAfterRemovingLine(",
      "          document,",
      "          lineIndex",
      "        )",
      "",
      "        if (newAttributes) {",
      "          this.pushState({",
      "            document: simplifyDocument(",
      "              setItem(",
      "                document,",
      "                'lines',",
      "                setItem(",
      "                  document.lines,",
      "                  lineIndex,",
      "                  setItem(document.lines[lineIndex], 'attributes', newAttributes)",
      "                )",
      "              )",
      "            )",
      "          })",
      "",
      "          e.preventDefault()",
      "        } else if (lineIndex !== 0) {",
      "          this.pushState({",
      "            document: simplifyDocument(",
      "              setItem(",
      "                document,",
      "                'lines',",
      "                setItem(",
      "                  removeItemFromArray(document.lines, lineIndex),",
      "                  lineIndex - 1,",
      "                  {",
      "                    ...document.lines[lineIndex - 1],",
      "                    content: document.lines[lineIndex - 1].content.concat(",
      "                      document.lines[lineIndex].content",
      "                    )",
      "                  }",
      "                )",
      "              )",
      "            ),",
      "            oldCaretPosition: this.caretPosition,",
      "            newCaretPosition: {",
      "              start: this.caretPosition.start - 1,",
      "              end: this.caretPosition.start - 1",
      "            }",
      "          })",
      "",
      "          e.preventDefault()",
      "        }",
      "      }",
      "    }",
      "",
      "    if (this.props.getNewDocumentStateFromKeyPress) {",
      "      const document = this.getDocument()",
      "      const startIndices = getStateIndices(document, this.caretPosition.start)",
      "      const endIndices = getStateIndices(document, this.caretPosition.end)",
      "",
      "      const selectedLines = document.lines.filter(",
      "        (line, index) =>",
      "          index >= startIndices.lineIndex && index <= endIndices.lineIndex",
      "      )",
      "      const startTextIndex = getTextIndexInLine(",
      "        selectedLines[0],",
      "        startIndices.contentIndex,",
      "        startIndices.stringIndex",
      "      )",
      "      const endTextIndex = getTextIndexInLine(",
      "        getLastItemOfArray(selectedLines),",
      "        endIndices.contentIndex,",
      "        endIndices.stringIndex",
      "      )",
      "",
      "      const newDocumentState = this.props.getNewDocumentStateFromKeyPress({",
      "        e: e.originalEvent,",
      "        caretPosition: this.caretPosition,",
      "        document,",
      "        selectedLines,",
      "        startIndices,",
      "        endIndices,",
      "        startTextIndex,",
      "        endTextIndex",
      "      })",
      "",
      "      if (newDocumentState) {",
      "        this.pushState({",
      "          document: simplifyDocument(newDocumentState.document),",
      "          oldCaretPosition: this.caretPosition,",
      "          newCaretPosition: newDocumentState.caretPosition",
      "        })",
      "",
      "        e.preventDefault()",
      "      }",
      "    }",
      "",
      "    if (this.props.attributeModifiers) {",
      "      for (const hotkey in this.props.attributeModifiers.block) {",
      "        const modifier = this.props.attributeModifiers.block[hotkey]",
      "",
      "        if (isKeyHotkey(hotkey, e.originalEvent)) {",
      "          this.applyBlockModifier(modifier)",
      "          e.preventDefault()",
      "        }",
      "      }",
      "",
      "      for (const hotkey in this.props.attributeModifiers.inline) {",
      "        const modifier = this.props.attributeModifiers.inline[hotkey]",
      "",
      "        if (isKeyHotkey(hotkey, e.originalEvent)) {",
      "          if (this.caretPosition.start === this.caretPosition.end) {",
      "            this.updateSelectedAttributes(modifier)",
      "          } else {",
      "            this.applyInlineModifier(modifier)",
      "          }",
      "",
      "          e.preventDefault()",
      "        }",
      "      }",
      "    }",
      "",
      "    if (this.props.onKeyDown) {",
      "      this.props.onKeyDown(e)",
      "    }",
      "  }",
      "",
      "  onChange = ({ document, oldCaretPosition, newCaretPosition }) => {",
      "    this.pushState({ document, oldCaretPosition, newCaretPosition })",
      "  }",
      "",
      "  formatUpdates = updates =>",
      "    this.state.selectedAttributes",
      "      ? updates.map(",
      "        update =>",
      "          update.type === 'insert'",
      "            ? {",
      "              ...update,",
      "              attributes: this.state.selectedAttributes",
      "            }",
      "            : update",
      "      )",
      "      : updates",
      "",
      "  onSelectionChange = ({ caretPosition }) => {",
      "    if (this.state.focused) {",
      "      this.setState({",
      "        caretPosition,",
      "        selectedAttributes:",
      "          caretPosition.start === caretPosition.end",
      "            ? getInlineAttributesAtPosition(",
      "              this.getDocument(this.state),",
      "              caretPosition.start",
      "            ) || {}",
      "            : null",
      "      })",
      "    }",
      "  }",
      "",
      "  onPaste = html => {",
      "    const document = this.getDocument()",
      "    const transfer = getEventTransfer(html)",
      "    const documentLength = getTextInDocument(document).length",
      "",
      "    const insert =",
      "      transfer.type === TRANSFER_TYPES.TEXT",
      "        ? {",
      "          type: 'insert',",
      "          text: transfer.data,",
      "          attributes: this.state.selectedAttributes",
      "        }",
      "        : {",
      "          type: 'insertFragment',",
      "          fragment: transfer.data",
      "        }",
      "",
      "    const amountToDelete = this.caretPosition.end - this.caretPosition.start",
      "    const newCaretPosition =",
      "      this.caretPosition.start +",
      "      (transfer.type === TRANSFER_TYPES.TEXT",
      "        ? transfer.data.length",
      "        : getTextInDocument(transfer.data).length)",
      "",
      "    this.pushState({",
      "      document: applyUpdates(document, [",
      "        {",
      "          type: 'retainAmount',",
      "          amount: this.caretPosition.start",
      "        },",
      "        {",
      "          type: 'deleteAmount',",
      "          amount: amountToDelete",
      "        },",
      "        insert,",
      "        {",
      "          type: 'retainAmount',",
      "          amount: documentLength - amountToDelete - this.caretPosition.start",
      "        }",
      "      ]),",
      "      oldCaretPosition: this.caretPosition,",
      "      newCaretPosition: {",
      "        start: newCaretPosition,",
      "        end: newCaretPosition",
      "      }",
      "    })",
      "  }",
      "",
      "  onCopy = e => {",
      "    const document = this.getDocument()",
      "",
      "    setEventTransfer(e, getSelectedFragment(document, this.caretPosition, true))",
      "  }",
      "",
      "  onCut = e => {",
      "    const document = this.getDocument()",
      "    const documentLength = getTextInDocument(document).length",
      "    const amountToDelete = this.caretPosition.end - this.caretPosition.start",
      "",
      "    setEventTransfer(e, getSelectedFragment(document, this.caretPosition, true))",
      "",
      "    this.pushState({",
      "      document: applyUpdates(document, [",
      "        {",
      "          type: 'retainAmount',",
      "          amount: this.caretPosition.start",
      "        },",
      "        {",
      "          type: 'deleteAmount',",
      "          amount: amountToDelete",
      "        },",
      "        {",
      "          type: 'retainAmount',",
      "          amount: documentLength - amountToDelete - this.caretPosition.start",
      "        }",
      "      ]),",
      "      oldCaretPosition: this.caretPosition,",
      "      newCaretPosition: {",
      "        start: this.caretPosition.start,",
      "        end: this.caretPosition.start",
      "      }",
      "    })",
      "  }",
      "",
      "  getDocument (state = this.state) {",
      "    return state.revisions[state.revisionIndex].document",
      "  }",
      "",
      "  applyBlockModifier (modifier) {",
      "    const document = this.getDocument()",
      "    const startIndices = getStateIndices(document, this.caretPosition.start)",
      "    const endIndices = getStateIndices(document, this.caretPosition.end)",
      "",
      "    const getAttributes = modifier(",
      "      getSelectedFragment(document, this.caretPosition)",
      "    )",
      "",
      "    this.pushState({",
      "      document: simplifyDocument(",
      "        applyBlockOperation(",
      "          document,",
      "          startIndices.lineIndex,",
      "          endIndices.lineIndex,",
      "          attributes => getAttributes(attributes || {})",
      "        )",
      "      )",
      "    })",
      "  }",
      "",
      "  applyInlineModifier (modifier) {",
      "    const document = this.getDocument()",
      "    const documentLength = getTextInDocument(document).length",
      "    const getAttributes = modifier(",
      "      getSelectedFragment(document, this.caretPosition)",
      "    )",
      "",
      "    this.pushState({",
      "      document: applyUpdates(document, [",
      "        {",
      "          type: 'retainAmount',",
      "          amount: this.caretPosition.start",
      "        },",
      "        {",
      "          type: 'retainAmount',",
      "          amount: this.caretPosition.end - this.caretPosition.start,",
      "          getNewAttributes: (attributes, ...args) =>",
      "            getAttributes(attributes || {}, ...args)",
      "        },",
      "        {",
      "          type: 'retainAmount',",
      "          amount: documentLength - this.caretPosition.end",
      "        }",
      "      ])",
      "    })",
      "  }",
      "",
      "  updateSelectedAttributes (modifier) {",
      "    const documentFragment = {",
      "      lines: [",
      "        {",
      "          content: [{ text: '', attributes: this.state.selectedAttributes }],",
      "          attributes: getSelectedFragment(this.getDocument(), this.caretPosition)",
      "            .lines[0].attributes",
      "        }",
      "      ]",
      "    }",
      "",
      "    this.setState({",
      "      selectedAttributes: modifier(documentFragment)(",
      "        this.state.selectedAttributes,",
      "        documentFragment.lines[0]",
      "      )",
      "    })",
      "  }",
      "",
      "  onToolbarClick = (e, type, modifier) => {",
      "    if (this.state.focused) {",
      "      if (type === 'inline') {",
      "        if (this.caretPosition.start === this.caretPosition.end) {",
      "          this.updateSelectedAttributes(modifier)",
      "        } else {",
      "          this.applyInlineModifier(modifier)",
      "        }",
      "      } else {",
      "        this.applyBlockModifier(modifier)",
      "      }",
      "",
      "      e.preventDefault()",
      "    }",
      "  }",
      "",
      "  onFocus = () => {",
      "    this.setState({ focused: true })",
      "  }",
      "",
      "  onBlur = () => {",
      "    this.setState({ focused: false })",
      "  }",
      "",
      "  render ({ handlers, onPaste, toolbar }, { focused, selectedAttributes }) {",
      "    const document = this.getDocument()",
      "    const selectedFragment = getSelectedFragment(document, this.caretPosition)",
      "",
      "    const Prism = require('prismjs')",
      "    require('@/scss/prism.scss')",
      "    class HighlightJSON {",
      "      componentDidMount () {",
      "        Prism.highlightElement(this.base)",
      "      }",
      "",
      "      componentDidUpdate () {",
      "        Prism.highlightElement(this.base)",
      "      }",
      "",
      "      render ({ children }) {",
      "        this.base && (this.base.innerHTML = '')",
      "        return <pre class=\"language-js\">{children}</pre>",
      "      }",
      "    }",
      "",
      "    return (",
      "      <Container>",
      "        <Center>",
      "          <EditorToolbar>",
      "            {toolbar.map(",
      "              ({ type, info, getIsActive, handler, icon: Icon }, index) => (",
      "                <Tooltip text={info} key={index}>",
      "                  {({ focused: tooltipFocused }) => (",
      "                    <Icon",
      "                      onMouseDown={e => this.onToolbarClick(e, type, handler)}",
      "                      size={18}",
      "                      class={classes['toolbar-icon']}",
      "                      data-focused={tooltipFocused}",
      "                      data-active={",
      "                        focused",
      "                          ? type === 'block'",
      "                            ? selectedFragment.lines.every(line =>",
      "                              getIsActive(line.attributes)",
      "                            )",
      "                            : selectedAttributes",
      "                              ? getIsActive(selectedAttributes)",
      "                              : selectedFragment.lines.every(line =>",
      "                                line.content.every(content =>",
      "                                  getIsActive(content.attributes)",
      "                                )",
      "                              )",
      "                          : false",
      "                      }",
      "                    />",
      "                  )}",
      "                </Tooltip>",
      "              )",
      "            )}",
      "          </EditorToolbar>",
      "          <TextEditor",
      "            handlers={handlers}",
      "            document={document}",
      "            caretPosition={this.caretPosition}",
      "            onChange={this.onChange}",
      "            onKeyDown={this.onKeyDown}",
      "            onSelectionChange={this.onSelectionChange}",
      "            onPaste={this.onPaste}",
      "            onFocus={this.onFocus}",
      "            onBlur={this.onBlur}",
      "            onCut={this.onCut}",
      "            onCopy={this.onCopy}",
      "            formatUpdates={this.formatUpdates}",
      "          />",
      "          <HighlightJSON>",
      "            {JSON.stringify(",
      "              { document, caretPosition: this.caretPosition },",
      "              null,",
      "              2",
      "            )}",
      "          </HighlightJSON>",
      "        </Center>",
      "      </Container>",
      "    )",
      "  }",
      "}",
      "",
      "const Container = ({ children }) => (",
      "  <div",
      "    style={{",
      "      position: 'fixed',",
      "      paddingTop: require('@/scss/constants').default.headerHeight,",
      "      top: 0,",
      "      right: 0,",
      "      bottom: 0,",
      "      left: 0,",
      "      background: '#fff',",
      "      overflow: 'scroll',",
      "      paddingBottom: '80px'",
      "    }}",
      "  >",
      "    {children}",
      "  </div>",
      ")",
      "",
      "const Center = ({ children }) => (",
      "  <div style={{ maxWidth: '740px', margin: 'auto' }}>{children}</div>",
      ")",
      "",
      "const EditorToolbar = ({ children }) => (",
      "  <div",
      "    style={{",
      "      position: 'relative',",
      "      padding: '15px 11px',",
      "      borderBottom: '2px solid #eee',",
      "      zIndex: 98",
      "    }}",
      "  >",
      "    {children}",
      "  </div>",
      ")"
    ]
  })
});
